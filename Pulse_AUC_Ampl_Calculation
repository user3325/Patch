import numpy as np
import scipy.io as sio
from scipy.integrate import trapezoid
from scipy.signal import find_peaks
from scipy.ndimage import gaussian_filter1d  # For smoothing
import os
import tkinter as tk
from tkinter import filedialog, messagebox
import matplotlib
# matplotlib.use('TkAgg')  # Let matplotlib choose the default backend
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

def detect_pulses(current, time, min_duration=0.3, min_amplitude=5.0):
    """Detect pulses in the current trace with amplitude rounded to 5 pA steps."""
    try:
        # Calculate baseline from first 10 seconds
        baseline_current = np.mean(current[time < 10])
        print(f"Baseline current: {baseline_current:.2f} pA")
        
        # Apply Gaussian smoothing to the current trace to reduce noise
        dt = time[1] - time[0]
        noise_duration = 0.012093945  # Use the longer noise duration provided
        sampling_rate = 1 / dt
        sigma = noise_duration * sampling_rate
        print(f"Smoothing current trace with Gaussian sigma={sigma:.2f} (noise duration={noise_duration} s, dt={dt} s)")
        smoothed_current = gaussian_filter1d(current, sigma=sigma)
        
        pulses = []
        start_time = None
        min_samples = int(min_duration / dt)
        
        for i in range(1, len(smoothed_current)):
            # Detect pulse onset
            if abs(smoothed_current[i] - baseline_current) >= min_amplitude and abs(smoothed_current[i-1] - baseline_current) < min_amplitude:
                start_time = time[i]
            # Detect pulse offset
            if abs(smoothed_current[i] - baseline_current) < min_amplitude and abs(smoothed_current[i-1] - baseline_current) >= min_amplitude and start_time is not None:
                end_time = time[i]
                duration = end_time - start_time
                if duration >= min_duration:
                    pulse_indices = (time >= start_time) & (time <= end_time)
                    # Use the smoothed current to calculate amplitude
                    amplitude = np.max(np.abs(smoothed_current[pulse_indices] - baseline_current))
                    print(f"Raw amplitude for pulse at {start_time:.2f} s: {amplitude:.2f} pA")
                    # Round amplitude to nearest 5 pA step
                    rounded_amplitude = round(amplitude / 5) * 5
                    print(f"Rounded amplitude: {rounded_amplitude:.2f} pA")
                    # Validate that the amplitude is a multiple of 5
                    if rounded_amplitude % 5 != 0:
                        print(f"Warning: Amplitude {rounded_amplitude} pA is not a multiple of 5 pA at {start_time:.2f} s")
                    pulses.append((start_time, end_time, rounded_amplitude))
                start_time = None
        print(f"Detected {len(pulses)} pulses with amplitude >= {min_amplitude} pA (rounded to 5 pA steps)")
        return pulses
    except Exception as e:
        print(f"Error detecting pulses: {e}")
        return []

class PulseAnalysisGUI:
    def __init__(self, root, time, voltage, pulses, file_name, output_dir, callback):
        print("Initializing PulseAnalysisGUI...")
        self.root = root
        self.time = time
        self.voltage = voltage
        self.pulses = pulses
        self.file_name = file_name
        self.output_dir = output_dir
        self.callback = callback
        self.selected_pulses = []
        self.current_pulse_idx = 0
        
        self.root.title(f"Pulse Analysis: {os.path.basename(file_name)}")
        
        # Output directory selection
        self.dir_frame = tk.Frame(self.root)
        self.dir_frame.pack(pady=5)
        tk.Label(self.dir_frame, text="Output Directory:").pack(side=tk.LEFT)
        self.dir_entry = tk.Entry(self.dir_frame, width=50)
        self.dir_entry.insert(0, output_dir)
        self.dir_entry.pack(side=tk.LEFT, padx=5)
        tk.Button(self.dir_frame, text="Browse", command=self.browse_output_dir).pack(side=tk.LEFT)
        
        # Plot canvas
        self.fig = Figure(figsize=(8, 4))
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        
        # Pulse info
        self.info_label = tk.Label(self.root, text="", wraplength=600)
        self.info_label.pack(pady=5)
        
        # Status message
        self.status_label = tk.Label(self.root, text="", fg="blue")
        self.status_label.pack(pady=5)
        
        # Buttons
        self.button_frame = tk.Frame(self.root)
        self.button_frame.pack(pady=5)
        self.prev_button = tk.Button(self.button_frame, text="Previous Pulse", command=self.prev_pulse)
        self.prev_button.pack(side=tk.LEFT, padx=5)
        tk.Button(self.button_frame, text="Save Pulse", command=self.save_pulse).pack(side=tk.LEFT, padx=5)
        tk.Button(self.button_frame, text="Skip Pulse", command=self.skip_pulse).pack(side=tk.LEFT, padx=5)
        tk.Button(self.button_frame, text="Next Pulse", command=self.next_pulse).pack(side=tk.LEFT, padx=5)
        
        self.update_button_states()
        print("Calling plot_pulse...")
        self.plot_pulse()

    def browse_output_dir(self):
        try:
            directory = filedialog.askdirectory(initialdir=self.output_dir)
            if directory:
                self.dir_entry.delete(0, tk.END)
                self.dir_entry.insert(0, directory)
                self.output_dir = directory
        except Exception as e:
            messagebox.showerror("Error", f"Failed to open directory dialog: {e}")

    def update_button_states(self):
        """Enable/disable navigation buttons based on current pulse index."""
        self.prev_button.config(state='disabled' if self.current_pulse_idx == 0 else 'normal')

    def plot_pulse(self):
        print(f"plot_pulse: Current pulse index = {self.current_pulse_idx}, Total pulses = {len(self.pulses)}")
        if self.current_pulse_idx >= len(self.pulses):
            print("No more pulses to plot, calling finish...")
            self.finish()
            return
        
        onset, offset, amplitude = self.pulses[self.current_pulse_idx]
        self.ax.clear()
        
        # Calculate baseline (3 seconds before onset)
        baseline_samples = int(3.0 / (self.time[1] - self.time[0]))
        onset_idx = np.where(self.time >= onset)[0][0]
        baseline_start_idx = max(0, onset_idx - baseline_samples)
        baseline_voltage = np.mean(self.voltage[baseline_start_idx:onset_idx])
        baseline_start_time = self.time[baseline_start_idx]
        print(f"Pulse {self.current_pulse_idx+1}: Baseline voltage={baseline_voltage:.2f} mV (3 s before onset)")
        
        # Calculate t1, t2, AUC, min voltage (within 1 s after offset), delta voltage, and AP count
        t1, t2, auc, delta_voltage, min_voltage_ahp, min_voltage_time_ahp, ap_count = None, None, None, None, None, None, 0
        t2_at_trace_end = False
        warning = ""
        try:
            if np.isnan(baseline_voltage):
                warning = "Baseline voltage is NaN"
            else:
                # AP count during pulse (onset to offset)
                pulse_idx = (self.time >= onset) & (self.time <= offset)
                pulse_voltage = self.voltage[pulse_idx]
                if len(pulse_voltage) > 0:
                    peaks, _ = find_peaks(pulse_voltage, height=0, prominence=10)  # Peaks >0 mV, prominence 10 mV
                    ap_count = len(peaks)
                print(f"Pulse {self.current_pulse_idx+1}: AP count={ap_count}")
                
                offset_idx = np.where(self.time >= offset)[0][0]
                post_pulse_voltage = self.voltage[offset_idx:]
                post_pulse_time = self.time[offset_idx:]
                t1_idx = np.where(post_pulse_voltage < baseline_voltage - 1.0)[0]
                if len(t1_idx) == 0:
                    warning = "No t1 found (no significant hyperpolarization)"
                else:
                    t1 = post_pulse_time[t1_idx[0]]
                    min_t2_time = t1 + 0.1  # Minimum 0.1 s after t1 for AUC
                    next_pulse_onset = self.pulses[self.current_pulse_idx + 1][0] if self.current_pulse_idx + 1 < len(self.pulses) else self.time[-1]
                    max_t2_time = next_pulse_onset
                    dt = self.time[1] - self.time[0]
                    t2_candidates = np.where((np.abs(post_pulse_voltage[t1_idx[0]:] - baseline_voltage) < 1.0) & 
                                           (post_pulse_time[t1_idx[0]:] >= min_t2_time) & 
                                           (post_pulse_time[t1_idx[0]:] <= max_t2_time))[0]
                    if len(t2_candidates) == 0:
                        warning = "t2 set to just before next pulse onset, AUC calculated to t2"
                        t2 = max_t2_time - dt
                        t2_at_trace_end = True
                    else:
                        t2 = post_pulse_time[t1_idx[0] + t2_candidates[0]]
                    auc_idx = (self.time >= t1) & (self.time <= t2)
                    auc_time = self.time[auc_idx]
                    auc_voltage = self.voltage[auc_idx] - baseline_voltage
                    auc = trapezoid(auc_voltage, auc_time)
                    print(f"Pulse {self.current_pulse_idx+1}: t1={t1:.2f} s, t2={t2:.2f} s, AUC={auc:.2f} mV*s, Partial={t2_at_trace_end}")
                    
                    # Min voltage after t1 and within 1 s after offset (afterhyperpolarization) with Gaussian smoothing
                    ahp_end = min(offset + 1.0, t2, self.time[-1])
                    ahp_start = max(offset, t1)  # Start at t1 to ensure AHP is after t1
                    ahp_idx = (self.time >= ahp_start) & (self.time <= ahp_end)
                    ahp_voltage = self.voltage[ahp_idx]
                    ahp_time = self.time[ahp_idx]
                    if len(ahp_voltage) > 0:
                        # Apply Gaussian smoothing based on the longer noise duration
                        noise_duration = 0.012093945  # Use the longer duration
                        sampling_rate = 1 / dt
                        sigma = noise_duration * sampling_rate  # Sigma in samples
                        print(f"Pulse {self.current_pulse_idx+1}: Smoothing with Gaussian sigma={sigma:.2f} (noise duration={noise_duration} s, dt={dt} s)")
                        filtered_voltage = gaussian_filter1d(ahp_voltage, sigma=sigma)
                        # Debug: Print filtered voltage stats
                        print(f"Pulse {self.current_pulse_idx+1}: AHP window from {ahp_start:.2f} s to {ahp_end:.2f} s")
                        print(f"Pulse {self.current_pulse_idx+1}: Filtered voltage min={np.min(filtered_voltage):.2f} mV, max={np.max(filtered_voltage):.2f} mV")
                        # Set a threshold for AHP (1.5 mV below baseline)
                        ahp_threshold = baseline_voltage - 1.5
                        potential_ahp = filtered_voltage[filtered_voltage < ahp_threshold]
                        if len(potential_ahp) > 0:
                            min_voltage_ahp = np.min(potential_ahp)
                            min_idx = np.argmin(filtered_voltage)
                            min_voltage_time_ahp = ahp_time[min_idx]
                            # AHP as the difference from baseline to max negative voltage
                            ahp_value = baseline_voltage - min_voltage_ahp
                            print(f"Pulse {self.current_pulse_idx+1}: AHP detected at {min_voltage_time_ahp:.2f} s, min voltage={min_voltage_ahp:.2f} mV, AHP difference={ahp_value:.2f} mV")
                        else:
                            warning += " No significant AHP (below 1.5 mV) after t1; using baseline at t1"
                            min_voltage_ahp = baseline_voltage
                            min_voltage_time_ahp = t1
                            ahp_value = 0.0
                            print(f"Pulse {self.current_pulse_idx+1}: No significant AHP, setting to baseline ({baseline_voltage:.2f} mV) at t1 ({t1:.2f} s)")
                    else:
                        warning += " No data after t1 for AHP minimum voltage"
                        min_voltage_ahp = baseline_voltage
                        min_voltage_time_ahp = t1
                        ahp_value = 0.0
                
                # Delta voltage: min voltage within 1 s after offset
                window_end = min(self.time[-1], offset + 1.0)
                delta_idx = (self.time >= offset) & (self.time <= window_end)
                if np.any(delta_idx):
                    min_voltage = np.min(self.voltage[delta_idx])
                    delta_voltage = baseline_voltage - min_voltage
                else:
                    warning += " No data within 1 s post-offset for delta voltage"
        except Exception as e:
            warning = f"Error calculating t1/t2/AUC/delta/AP: {e}"
        
        # Plot
        window_start = max(0, onset - 5)
        window_end = t2 + 0.5 if t2 else offset
        next_pulse_onset = self.pulses[self.current_pulse_idx + 1][0] if self.current_pulse_idx + 1 < len(self.pulses) else self.time[-1]
        window_end = min(max(window_end, offset), next_pulse_onset)
        window_idx = (self.time >= window_start) & (self.time <= window_end)
        
        self.ax.plot(self.time[window_idx], self.voltage[window_idx], label='Voltage (mV)', color='blue')
        self.ax.axvspan(onset, offset, alpha=0.2, color='yellow', label='Pulse')
        self.ax.axvspan(baseline_start_time, onset, alpha=0.1, color='gray', label='Baseline (3 s)')
        self.ax.axhline(baseline_voltage, color='gray', linestyle='--', label=f'Baseline ({baseline_voltage:.2f} mV)')
        
        if t1:
            self.ax.axvline(t1, color='red', linestyle=':', label=f't1 ({t1:.2f} s)')
        if t2 and t1:
            linestyle = '--' if t2_at_trace_end else ':'
            auc_alpha = 0.2 if t2_at_trace_end else 0.3
            self.ax.axvline(t2, color='green', linestyle=linestyle, label=f't2 ({t2:.2f} s)')
            if auc is not None:
                auc_idx = (self.time >= t1) & (self.time <= t2)
                auc_label = f'AUC ({auc:.2f} mV*s, partial)' if t2_at_trace_end else f'AUC ({auc:.2f} mV*s)'
                self.ax.fill_between(self.time[auc_idx], self.voltage[auc_idx], baseline_voltage,
                                   alpha=auc_alpha, color='purple', label=auc_label)
        if min_voltage_ahp is not None and min_voltage_time_ahp is not None:
            self.ax.plot(min_voltage_time_ahp, min_voltage_ahp, 'ro', 
                        label=f'AHP Min Voltage ({min_voltage_ahp:.2f} mV)')
        
        self.ax.set_xlabel('Time (s)')
        self.ax.set_ylabel('Voltage (mV)')
        self.ax.set_title(f'Pulse {self.current_pulse_idx+1}/{len(self.pulses)} at {onset:.2f} s')
        self.ax.legend()
        self.ax.grid(True)
        self.fig.tight_layout()
        print("Drawing canvas...")
        self.canvas.draw()
        
        # Update info
        info_text = (f"Pulse {self.current_pulse_idx+1}/{len(self.pulses)}: Onset={onset:.2f} s, "
                    f"Amplitude={amplitude:.2f} pA, Baseline={baseline_voltage:.2f} mV, AP Count={ap_count}\n")
        if t1:
            info_text += f"t1={t1:.2f} s, "
        if t2:
            info_text += f"t2={t2:.2f} s, "
        if auc is not None:
            auc_text = f"AUC={auc:.2f} mV*s (partial)" if t2_at_trace_end else f"AUC={auc:.2f} mV*s"
            info_text += auc_text + ", "
        if delta_voltage is not None:
            info_text += f"Delta Voltage (1 s post-offset)={delta_voltage:.2f} mV"
        if min_voltage_ahp is not None and min_voltage_time_ahp is not None:
            info_text += f"\nAHP Min Voltage (1 s post-offset)={min_voltage_ahp:.2f} mV at {min_voltage_time_ahp:.2f} s"
            if 'ahp_value' in locals():
                info_text += f", AHP Difference={ahp_value:.2f} mV"
        if warning:
            info_text += f"\nWarning: {warning}"
        self.info_label.config(text=info_text)
        
        self.current_result = (onset, amplitude, baseline_voltage, auc if auc is not None else np.nan, 
                             delta_voltage if delta_voltage is not None else np.nan, ap_count)
        self.status_label.config(text="")
        self.update_button_states()
        print("Pulse plotted successfully.")

    def save_pulse(self):
        self.selected_pulses.append(self.current_result)
        self.status_label.config(text=f"Pulse {self.current_pulse_idx+1} saved", fg="green")
        print(f"Saved pulse {self.current_pulse_idx+1}: {self.current_result}")
        self.next_pulse()

    def skip_pulse(self):
        self.status_label.config(text=f"Pulse {self.current_pulse_idx+1} skipped", fg="red")
        print(f"Skipped pulse {self.current_pulse_idx+1}")
        self.next_pulse()

    def next_pulse(self):
        self.current_pulse_idx += 1
        self.plot_pulse()

    def prev_pulse(self):
        if self.current_pulse_idx > 0:
            self.current_pulse_idx -= 1
            self.plot_pulse()

    def finish(self):
        print("Finishing GUI session...")
        # Save results
        output_file = os.path.join(self.output_dir, f"analysis_results_{os.path.splitext(os.path.basename(self.file_name))[0]}.txt")
        try:
            os.makedirs(self.output_dir, exist_ok=True)
            with open(output_file, 'w') as f:
                f.write("Pulse Onset (s)\tAmplitude (pA)\tBaseline Voltage (mV)\tAUC (mV*s)\tDelta Voltage (mV)\tAP Count\n")
                for onset, amplitude, baseline, auc, delta, ap_count in self.selected_pulses:
                    auc_str = f"{auc:.2f}" if not np.isnan(auc) else "N/A"
                    delta_str = f"{delta:.2f}" if not np.isnan(delta) else "N/A"
                    f.write(f"{onset:.2f}\t{amplitude:.2f}\t{baseline:.2f}\t{auc_str}\t{delta_str}\t{ap_count}\n")
            print(f"Results saved to {output_file}")
            print(f"Total saved pulses: {len(self.selected_pulses)}")
        except Exception as e:
            print(f"Error saving results to {output_file}: {e}")
        
        self.callback(self.selected_pulses)
        self.root.quit()
        self.root.destroy()

def analyze_hyperpol(file_path, output_dir):
    """Analyze a single .mat file and show GUI for pulse selection."""
    print(f"\nProcessing file: {os.path.basename(file_path)}")
    try:
        mat = sio.loadmat(file_path)
        # Dynamically find voltage and current variables
        voltage_vars = [key for key in mat.keys() if key.endswith('_Voltage') and not key.startswith('__')]
        current_vars = [key for key in mat.keys() if key.endswith('_Current') and not key.startswith('__')]
        
        if len(voltage_vars) != 1 or len(current_vars) != 1:
            print(f"Error: Expected exactly one voltage and one current variable in {file_path}")
            print(f"Found voltage variables: {voltage_vars}")
            print(f"Found current variables: {current_vars}")
            print("Available variables:", list(mat.keys()))
            return None, None, None
        
        voltage_var = voltage_vars[0]
        current_var = current_vars[0]
        print(f"Using voltage variable: {voltage_var}, current variable: {current_var}")
        
        voltage_data = mat[voltage_var][0, 0]
        current_data = mat[current_var][0, 0]
        
        voltage_values = voltage_data['values'].flatten()
        current_values = current_data['values'].flatten()
        voltage_interval = voltage_data['interval'][0][0]
        voltage_length = voltage_data['length'][0][0]
        current_interval = current_data['interval'][0][0]
        current_length = current_data['length'][0][0]
        
        voltage_time = np.arange(0, voltage_length * voltage_interval, voltage_interval)[:len(voltage_values)]
        current_time = np.arange(0, current_length * current_interval, current_interval)[:len(current_values)]
        
        if voltage_interval != current_interval:
            print(f"Warning: Voltage and current sampling intervals differ ({voltage_interval} vs {current_interval})")
            from scipy.interpolate import interp1d
            interp_func = interp1d(current_time, current_values, kind='linear', fill_value='extrapolate')
            current_values = interp_func(voltage_time)
            time = voltage_time
        else:
            time = voltage_time
            current_values = current_values[:len(time)]
        
        if len(voltage_values) != len(time) or len(current_values) != len(time):
            print(f"Error: Mismatched array lengths in {file_path}")
            print(f"Time: {len(time)}, Voltage: {len(voltage_values)}, Current: {len(current_values)}")
            return None, None, None
        
    except Exception as e:
        print(f"Error loading {file_path}: {e}")
        return None, None, None

    pulses = detect_pulses(current_values, time)
    if not pulses:
        print(f"No pulses detected in {os.path.basename(file_path)}")
        return None, None, None

    # Calculate metrics for all pulses (for auto-save if GUI fails)
    auto_pulses = []
    dt = time[1] - time[0]
    for pulse_idx, (onset, offset, amplitude) in enumerate(pulses):
        baseline_samples = int(3.0 / (time[1] - time[0]))
        onset_idx = np.where(time >= onset)[0][0]
        baseline_start_idx = max(0, onset_idx - baseline_samples)
        baseline_voltage = np.mean(voltage_values[baseline_start_idx:onset_idx])
        print(f"Auto pulse at {onset:.2f} s: Baseline voltage={baseline_voltage:.2f} mV (3 s before onset)")
        
        t1, t2, auc, delta_voltage, ap_count = None, None, None, None, 0
        try:
            if not np.isnan(baseline_voltage):
                # AP count during pulse
                pulse_idx = (time >= onset) & (time <= offset)
                pulse_voltage = voltage_values[pulse_idx]
                if len(pulse_voltage) > 0:
                    peaks, _ = find_peaks(pulse_voltage, height=0, prominence=10)
                    ap_count = len(peaks)
                print(f"Auto pulse at {onset:.2f} s: AP count={ap_count}")
                
                offset_idx = np.where(time >= offset)[0][0]
                post_pulse_voltage = voltage_values[offset_idx:]
                post_pulse_time = time[offset_idx:]
                t1_idx = np.where(post_pulse_voltage < baseline_voltage - 1.0)[0]
                if len(t1_idx) > 0:
                    t1 = post_pulse_time[t1_idx[0]]
                    min_t2_time = t1 + 0.1
                    next_pulse_onset = pulses[pulse_idx + 1][0] if pulse_idx + 1 < len(pulses) else time[-1]
                    max_t2_time = next_pulse_onset
                    t2_candidates = np.where((np.abs(post_pulse_voltage[t1_idx[0]:] - baseline_voltage) < 1.0) & 
                                           (post_pulse_time[t1_idx[0]:] >= min_t2_time) & 
                                           (post_pulse_time[t1_idx[0]:] <= max_t2_time))[0]
                    if len(t2_candidates) > 0:
                        t2 = post_pulse_time[t1_idx[0] + t2_candidates[0]]
                    else:
                        t2 = max_t2_time - dt
                        print(f"Warning: t2 set to just before next pulse onset for pulse at {onset:.2f} s, AUC calculated to t2")
                    auc_idx = (time >= t1) & (time <= t2)
                    auc_time = time[auc_idx]
                    auc_voltage = voltage_values[auc_idx] - baseline_voltage
                    auc = trapezoid(auc_voltage, auc_time)
                    print(f"Auto pulse at {onset:.2f} s: t1={t1:.2f} s, t2={t2:.2f} s, AUC={auc:.2f} mV*s")
                # Delta voltage
                window_end = min(time[-1], offset + 1.0)
                delta_idx = (time >= offset) & (time <= window_end)
                if np.any(delta_idx):
                    min_voltage = np.min(voltage_values[delta_idx])
                    delta_voltage = baseline_voltage - min_voltage
        except Exception as e:
            print(f"Error calculating metrics for pulse at {onset:.2f} s: {e}")
        
        auto_pulses.append((onset, amplitude, baseline_voltage, auc if auc is not None else np.nan, 
                           delta_voltage if delta_voltage is not None else np.nan, ap_count))

    # Try to run GUI
    selected_pulses = []
    try:
        root = tk.Tk()
        print(f"Initializing GUI for {os.path.basename(file_path)}")
        def callback(results):
            nonlocal selected_pulses
            selected_pulses = results
            print(f"GUI returned {len(selected_pulses)} selected pulses for {os.path.basename(file_path)}")
        
        app = PulseAnalysisGUI(root, time, voltage_values, pulses, file_path, output_dir, callback)
        print("Starting GUI main loop...")
        root.mainloop()
        print("GUI main loop finished.")
    except Exception as e:
        print(f"Error initializing GUI for {file_path}: {e}")
        print("Auto-saving all detected pulses due to GUI failure")
        selected_pulses = auto_pulses
        if 'root' in locals():
            root.quit()
            root.destroy()

    # Save results if pulses exist
    if selected_pulses:
        output_file = os.path.join(output_dir, f"analysis_results_{os.path.splitext(os.path.basename(file_path))[0]}.txt")
        try:
            os.makedirs(output_dir, exist_ok=True)
            with open(output_file, 'w') as f:
                f.write("Pulse Onset (s)\tAmplitude (pA)\tBaseline Voltage (mV)\tAUC (mV*s)\tDelta Voltage (mV)\tAP Count\n")
                for onset, amplitude, baseline, auc, delta, ap_count in selected_pulses:
                    auc_str = f"{auc:.2f}" if not np.isnan(auc) else "N/A"
                    delta_str = f"{delta:.2f}" if not np.isnan(delta) else "N/A"
                    f.write(f"{onset:.2f}\t{amplitude:.2f}\t{baseline:.2f}\t{auc_str}\t{delta_str}\t{ap_count}\n")
            print(f"Results saved to {output_file}")
            print(f"Total saved pulses: {len(selected_pulses)}")
        except Exception as e:
            print(f"Error saving results to {output_file}: {e}")

    return selected_pulses, output_dir, os.path.basename(file_path)

def select_and_analyze_files():
    """Open file dialog and analyze selected .mat files."""
    print("Starting select_and_analyze_files...")
    try:
        root = tk.Tk()
        print("Tk root created.")
        root.withdraw()
        print("Opening file dialog...")
        file_paths = filedialog.askopenfilenames(
            title="Select .mat files",
            filetypes=[("MAT files", "*.mat")]
        )
        print("File dialog closed.")
        print("Selected files:", file_paths)
        if not file_paths:
            print("No files selected. Exiting.")
            root.destroy()
            return

        # Set output directory to AUC_Analysis subdirectory
        base_dir = os.path.dirname(file_paths[0])
        output_dir = os.path.join(base_dir, "AUC_Analysis")
        
        for file_path in file_paths:
            print(f"Starting analysis for {os.path.basename(file_path)}")
            results, _, file_name = analyze_hyperpol(file_path, output_dir)
            if results:
                print(f"File {file_name}: {len(results)} pulses saved")
            print(f"Finished analysis for {os.path.basename(file_path)}")

        root.destroy()
        print("select_and_analyze_files completed.")
    except Exception as e:
        print(f"Error in file selection: {e}")
        if 'root' in locals():
            root.destroy()

if __name__ == "__main__":
    print("Script started...")
    select_and_analyze_files()
    print("Script finished.")
